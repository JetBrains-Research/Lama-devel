import List;
import Ref;
import Collection;

local tab = emptyHashTab ();

public fun equal (x, y) {
  case x of
    #unboxed ->
      case y of
        #unboxed -> x == y
      | _ -> false
      esac
  | #string ->
    case y of
      #string -> x == y
    | _ -> false
    esac
  | #fun ->
    case y of
      #fun ->
        local resx = findMap (tab, (x [0])),
              resy = findMap (tab, (y [0]));
        local alreadyEqual =
          case resx of
            Some (r1) ->
              case resy of
                Some (r2) -> (r1 [0] == r2 [0])
              | None -> false
              esac
          | None -> false
          esac;
        if alreadyEqual           then true
        elif x.length != y.length then false
        elif x.length == 1        then (x [0] == y [0])
        else
          local i = 1, ans = ref (true);
          case resx of
            Some (r1) ->
              case resy of
                Some (r2) -> r2 := deref (r1)
              | None -> addHashTab (tab, (y [0]), r1)
              esac
          | None ->
              case resy of
                Some (r2) -> addHashTab (tab, (x [0]), r2)
              | None ->
                local r = ref (fun (x) {x});
                addHashTab (tab, (x [0]), r);
                addHashTab (tab, (y [0]), r)
              esac
          esac;
          printf ("%d", x.length);
          for skip, i < x.length, i := i + 1 do
            ans := deref (ans) && equal (x [i], y [i])
          od;
          deref (ans)
        fi
    | _ -> false
    esac
  | _ ->
    case y of
      #unboxed -> false
    | #string -> false
    | #fun -> false
    | _ ->
      if (x.length == y.length) then
        local i = 0, ans = ref (true);
        for skip, i < x.length, i := i + 1 do
          ans := deref (ans) && equal (x [i], y [i])
        od;
        ans
      else false
      fi
    esac
  esac
}
