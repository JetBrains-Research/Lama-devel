import List;
import Ref;
import Collection;

public fun equal (tab, x, y) {
  case x of
    #unboxed ->
      case y of
        #unboxed -> x == y
      | _ -> false
      esac
  | #string ->
    case y of
      #string -> x == y
    | _ -> false
    esac
  | #fun ->
    case y of
      #fun ->
        local resx = findMap (deref (tab), (x [0])),
              resy = findMap (deref (tab), (y [0]));
        local alreadyEqual =
          case resx of
            Some (r1) ->
              case resy of
                Some (r2) -> (r1 [0] == r2 [0])
              | None -> false
              esac
          | None -> false
          esac;
        if alreadyEqual           then true
        elif x.length != y.length then false
        elif x.length == 1        then (x [0] == y [0])
        else
          local i = 1, ans = true;
          case resx of
            Some (r1) ->
              case resy of
                Some (r2) -> tab ::= changeHashTab (deref (tab), (y [0]), r1)
              | None -> tab ::= addHashTab (deref (tab), (y [0]), r1)
              esac
          | None ->
              case resy of
                Some (r2) -> tab ::= addHashTab (deref (tab), (x [0]), r2)
              | None ->
                local r = ref (fun (x) {x});
                tab ::= addHashTab (deref (tab), (x [0]), r);
                tab ::= addHashTab (deref (tab), (y [0]), r)
                --printf ("%d and %d added to tab \n", x [0], y [0])
              esac
          esac;
          for skip, i < x.length, i := i + 1 do
            ans := ans && equal (tab, x [i], y [i])
          od;
          ans
        fi
    | _ -> false
    esac
  | _ ->
    case y of
      #unboxed -> false
    | #string -> false
    | #fun -> false
    | _ ->
      if (x.length == y.length) then
        local i = 0, ans = true;
        for skip, i < x.length, i := i + 1 do
          ans := ans && equal (tab, x [i], y [i])
        od;
        ans
      else false
      fi
    esac
  esac
}
