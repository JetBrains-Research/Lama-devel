import List;
import Ref;
import Collection;

local tab = emptyHashTab ();

--fun root (node, tab) {
--  case node of
--    Node (x, prnt) ->
--      local res = root (prnt);
--      [res.fst, changeHashTab (res.snd, x, Node (x, res.fst))]
--  | Root (x) -> [node, tab]
--  esac
--}

fun root (x, tab) {
  local yy = findHashTab (tab, (x [0]));
  case yy of
    Some (y) ->
      if (x == y) then [x, tab]
      else
        local z = root (y, tab);
        [z.fst, changeHashTab (z.snd, (x [0]), z.fst)]
      fi
  | None -> [x, tab]
  esac
}

public fun equal (x, y) {
  case x of
    #unboxed -> (compare (x, y) == 0)
  | #string -> (compare (x, y) == 0)
  | #fun ->
    case y of
      #fun ->
        local resx = root (x, tab),
              resy = root (y, resx.snd);
        tab := resy.snd;
        if (resx.fst) == (resy.fst) then true
        elif x.length != y.length   then false
        elif x.length == 1          then (x [0] == y [0])
        else
          local i = 1, ans = true;
          tab := changeHashTab (tab, (x[0]), resy.fst);
          for skip, i < x.length, i := i + 1 do
            ans := ans && equal (x [i], y [i])
          od;
          ans
        fi
    | _ -> false
    esac
  | _ ->
    case y of
      #unboxed -> false
    | #string -> false
    | #fun -> false
    | _ ->
      if (x.length == y.length) then
        local i = 0, ans = true;
        for skip, i < x.length, i := i + 1 do
          ans := ans && equal (x [i], y [i])
        od;
        ans
      else false
      fi
    esac
  esac
}
